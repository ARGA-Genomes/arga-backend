-- Recreate views to change dependency on old uuid
DROP MATERIALIZED VIEW overview;
DROP MATERIALIZED VIEW specimen_stats;
DROP VIEW whole_genomes;
DROP VIEW markers;
DROP VIEW genomic_components;

-- atlas cant figure out the primary key and foreign key change
ALTER TABLE dna_extracts DROP CONSTRAINT "dna_extracts_subsample_id_fkey";
ALTER TABLE sequences DROP CONSTRAINT "sequences_dna_extract_id_fkey";


-------
-- autogenerated by atlas. modified with fixes
-------
-- Drop "dna_extraction_events" table
DROP TABLE "public"."dna_extraction_events";
-- Drop "subsample_events" table
DROP TABLE "public"."subsample_events";
-- Modify "subsamples" table
ALTER TABLE "public"."subsamples" DROP CONSTRAINT "subsamples_pkey", DROP COLUMN "id", DROP COLUMN "dataset_id", DROP COLUMN "name_id", DROP COLUMN "record_id", DROP COLUMN "material_sample_id", DROP COLUMN "type_status", ALTER COLUMN "entity_id" SET NOT NULL, ADD COLUMN "species_name_id" bigint NOT NULL, ADD COLUMN "publication_id" character varying NULL, ADD COLUMN "subsample_id" character varying NOT NULL, ADD COLUMN "event_date" date NULL, ADD COLUMN "event_time" time NULL, ADD COLUMN "sample_type" character varying NULL, ADD COLUMN "name" character varying NULL, ADD COLUMN "custodian" character varying NULL, ADD COLUMN "description" character varying NULL, ADD COLUMN "notes" character varying NULL, ADD COLUMN "culture_method" character varying NULL, ADD COLUMN "culture_media" character varying NULL, ADD COLUMN "weight_or_volume" character varying NULL, ADD COLUMN "preservation_method" character varying NULL, ADD COLUMN "preservation_temperature" character varying NULL, ADD COLUMN "preservation_duration" character varying NULL, ADD COLUMN "quality" character varying NULL, ADD COLUMN "cell_type" character varying NULL, ADD COLUMN "cell_line" character varying NULL, ADD COLUMN "clone_name" character varying NULL, ADD COLUMN "lab_host" character varying NULL, ADD COLUMN "sample_processing" character varying NULL, ADD COLUMN "sample_pooling" character varying NULL, ADD PRIMARY KEY ("entity_id"), ADD
CONSTRAINT "subsamples_publication_id_fkey" FOREIGN KEY ("publication_id") REFERENCES "public"."publications" ("entity_id") ON UPDATE NO ACTION ON DELETE NO ACTION;
-- Create index "subsamples_species_name_id" to table: "subsamples"
CREATE INDEX "subsamples_species_name_id" ON "public"."subsamples" ("species_name_id");
-- Create "agents" table
CREATE TABLE "public"."agents" (
 "entity_id" character varying NOT NULL,
 "full_name" character varying NOT NULL,
 "orcid" character varying NULL,
 PRIMARY KEY ("entity_id")
);
-- Modify "dna_extracts" table
ALTER TABLE "public"."dna_extracts" DROP CONSTRAINT "dna_extracts_pkey", DROP COLUMN "id", DROP COLUMN "dataset_id", DROP COLUMN "name_id", ALTER COLUMN "subsample_id" TYPE character varying, DROP COLUMN "record_id", ALTER COLUMN "entity_id" SET NOT NULL, ADD COLUMN "species_name_id" bigint NOT NULL, ADD COLUMN "publication_id" character varying NULL, ADD COLUMN "extract_id" character varying NOT NULL, ADD COLUMN "event_date" date NULL, ADD COLUMN "event_time" time NULL, ADD COLUMN "extracted_by" character varying NULL, ADD COLUMN "material_extracted_by" character varying NULL, ADD COLUMN "nucleic_acid_type" character varying NULL, ADD COLUMN "preparation_type" character varying NULL, ADD COLUMN "preservation_type" character varying NULL, ADD COLUMN "preservation_method" character varying NULL, ADD COLUMN "extraction_method" character varying NULL, ADD COLUMN "concentration_method" character varying NULL, ADD COLUMN "conformation" character varying NULL, ADD COLUMN "concentration" double precision NULL, ADD COLUMN "concentration_unit" character varying NULL, ADD COLUMN "quantification" character varying NULL, ADD COLUMN "absorbance_260_230_ratio" double precision NULL, ADD COLUMN "absorbance_260_280_ratio" double precision NULL, ADD COLUMN "cell_lysis_method" character varying NULL, ADD COLUMN "action_extracted" character varying NULL, ADD COLUMN "number_of_extracts_pooled" character varying NULL, ADD PRIMARY KEY ("entity_id"), ADD
CONSTRAINT "dna_extracts_subsample_id_fkey" FOREIGN KEY ("subsample_id") REFERENCES "public"."subsamples" ("entity_id") ON UPDATE NO ACTION ON DELETE CASCADE, ADD
CONSTRAINT "dna_extracts_extracted_by_fkey" FOREIGN KEY ("extracted_by") REFERENCES "public"."agents" ("entity_id") ON UPDATE NO ACTION ON DELETE NO ACTION, ADD
CONSTRAINT "dna_extracts_material_extracted_by_fkey" FOREIGN KEY ("material_extracted_by") REFERENCES "public"."agents" ("entity_id") ON UPDATE NO ACTION ON DELETE NO ACTION, ADD
CONSTRAINT "dna_extracts_publication_id_fkey" FOREIGN KEY ("publication_id") REFERENCES "public"."publications" ("entity_id") ON UPDATE NO ACTION ON DELETE NO ACTION;
-- Create index "dna_extracts_species_name_id" to table: "dna_extracts"
CREATE INDEX "dna_extracts_species_name_id" ON "public"."dna_extracts" ("species_name_id");
-- Modify "sequences" table
ALTER TABLE "public"."sequences" ALTER COLUMN "dna_extract_id" TYPE character varying, ADD
CONSTRAINT "sequences_dna_extract_id_fkey" FOREIGN KEY ("dna_extract_id") REFERENCES "public"."dna_extracts" ("entity_id") ON UPDATE NO ACTION ON DELETE CASCADE;



-------
-- View recreation with new id references
-------

-- a convenience view that joins all the sequencing events. Will return duplicates of
-- a sequence if there are multiple events of the same type for a sequence
CREATE VIEW whole_genomes AS
SELECT
    sequences.id AS sequence_id,
    sequences.dataset_id,
    sequences.name_id,
    sequences.dna_extract_id,
    datasets.name AS dataset_name,
    sequences.record_id,
    collection_events.latitude,
    collection_events.longitude,
    deposition_events.accession,
    sequencing_events.sequenced_by,
    sequencing_events.material_sample_id,
    sequencing_events.estimated_size,
    assembly_events.assembled_by,
    assembly_events.name,
    assembly_events.version_status,
    assembly_events.quality,
    assembly_events.assembly_type,
    assembly_events.genome_size,
    annotation_events.annotated_by,
    annotation_events.representation,
    annotation_events.release_type,
    deposition_events.event_date AS release_date,
    deposition_events.submitted_by AS deposited_by,
    deposition_events.data_type,
    deposition_events.excluded_from_refseq
FROM sequences
JOIN datasets ON sequences.dataset_id = datasets.id
JOIN sequencing_events ON sequences.id = sequencing_events.sequence_id
JOIN assembly_events ON sequences.id = assembly_events.sequence_id
JOIN annotation_events ON sequences.id = annotation_events.sequence_id
JOIN deposition_events ON sequences.id = deposition_events.sequence_id
LEFT JOIN dna_extracts ON sequences.dna_extract_id = dna_extracts.entity_id
LEFT JOIN subsamples ON dna_extracts.subsample_id = subsamples.entity_id
LEFT JOIN specimens ON subsamples.specimen_id = specimens.entity_id
LEFT JOIN collection_events ON specimens.entity_id = collection_events.specimen_id;


-- All loci data
CREATE VIEW markers AS
SELECT DISTINCT
    sequences.id AS sequence_id,
    sequences.dataset_id,
    sequences.name_id,
    sequences.dna_extract_id,
    datasets.name AS dataset_name,
    sequences.record_id,
    collection_events.latitude,
    collection_events.longitude,
    deposition_events.accession,
    sequencing_events.sequenced_by,
    sequencing_events.material_sample_id,
    sequencing_events.target_gene,
    deposition_events.event_date AS release_date
FROM sequences
JOIN datasets ON sequences.dataset_id = datasets.id
JOIN sequencing_events ON sequences.id = sequencing_events.sequence_id
LEFT JOIN deposition_events ON sequences.id = deposition_events.sequence_id
LEFT JOIN dna_extracts ON sequences.dna_extract_id = dna_extracts.entity_id
LEFT JOIN subsamples ON dna_extracts.subsample_id = subsamples.entity_id
LEFT JOIN specimens ON subsamples.specimen_id = specimens.entity_id
LEFT JOIN collection_events ON specimens.entity_id = collection_events.specimen_id
WHERE sequencing_events.target_gene IS NOT NULL;


-- All data regarded as a genomic component
CREATE VIEW genomic_components AS
SELECT DISTINCT
    sequences.id AS sequence_id,
    sequences.dataset_id,
    sequences.name_id,
    sequences.dna_extract_id,
    datasets.name AS dataset_name,
    sequences.record_id,
    collection_events.latitude,
    collection_events.longitude,
    deposition_events.accession,
    sequencing_events.sequenced_by,
    sequencing_events.material_sample_id,
    sequencing_events.estimated_size,
    deposition_events.event_date AS release_date,
    deposition_events.submitted_by AS deposited_by,
    deposition_events.data_type,
    deposition_events.title,
    deposition_events.url,
    deposition_events.source_uri,
    deposition_events.funding_attribution,
    deposition_events.rights_holder,
    deposition_events.access_rights
FROM sequences
JOIN datasets ON sequences.dataset_id = datasets.id
JOIN sequencing_events ON sequences.id = sequencing_events.sequence_id
JOIN deposition_events ON sequences.id = deposition_events.sequence_id
LEFT JOIN assembly_events on sequences.id = assembly_events.sequence_id
LEFT JOIN dna_extracts ON sequences.dna_extract_id = dna_extracts.entity_id
LEFT JOIN subsamples ON dna_extracts.subsample_id = subsamples.entity_id
LEFT JOIN specimens ON subsamples.specimen_id = specimens.entity_id
LEFT JOIN collection_events ON specimens.entity_id = collection_events.specimen_id
WHERE assembly_events.id IS NULL AND target_gene IS NULL;


-- Statistics for all specimens
CREATE MATERIALIZED VIEW specimen_stats AS
SELECT DISTINCT
    specimens.entity_id,
    SUM(CASE WHEN sequences.record_id IS NOT NULL THEN 1 ELSE 0 END) OVER entities AS sequences,
    SUM(CASE WHEN annotation_events.representation IN ('Full', 'Partial') THEN 1 ELSE 0 END) OVER entities AS whole_genomes,
    SUM(CASE WHEN sequencing_events.target_gene IS NOT NULL THEN 1 ELSE 0 END) OVER entities AS loci,
    SUM(CASE WHEN sequencing_events.target_gene IS NULL AND assembly_events.id IS NULL THEN 1 ELSE 0 END) OVER entities AS other_genomic,
    SUM(CASE WHEN annotation_events.representation = 'Full' THEN 1 ELSE 0 END) OVER entities AS full_genomes,
    SUM(CASE WHEN annotation_events.representation = 'Partial' THEN 1 ELSE 0 END) OVER entities AS partial_genomes,
    SUM(CASE WHEN assembly_events.quality = 'Complete Genome' THEN 1 ELSE 0 END) OVER entities AS complete_genomes,
    SUM(CASE WHEN assembly_events.quality = 'Chromosome' THEN 1 ELSE 0 END) OVER entities AS assembly_chromosomes,
    SUM(CASE WHEN assembly_events.quality = 'Scaffold' THEN 1 ELSE 0 END) OVER entities AS assembly_scaffolds,
    SUM(CASE WHEN assembly_events.quality = 'Contig' THEN 1 ELSE 0 END) OVER entities AS assembly_contigs

FROM specimens
LEFT JOIN subsamples ON subsamples.specimen_id = specimens.entity_id
LEFT JOIN dna_extracts ON dna_extracts.subsample_id = subsamples.entity_id
LEFT JOIN sequences ON sequences.dna_extract_id = dna_extracts.entity_id
LEFT JOIN sequencing_events ON sequencing_events.sequence_id = sequences.id
LEFT JOIN annotation_events ON annotation_events.sequence_id = sequences.id
LEFT JOIN assembly_events ON assembly_events.sequence_id = sequences.id
WINDOW entities AS (partition BY specimens.entity_id ORDER BY specimens.entity_id DESC);

CREATE UNIQUE INDEX specimen_stats_entity_id ON specimen_stats(entity_id);


-- Very high level stats for all data in the ARGA database
CREATE MATERIALIZED VIEW overview AS
SELECT 'data_type' AS category, 'sequences' AS name, count(*) AS total FROM sequences
UNION ALL SELECT 'data_type' AS category, 'whole_genomes' AS name, count(*) AS total FROM whole_genomes
UNION ALL SELECT 'data_type' AS category, 'loci' AS name, count(*) AS total FROM markers
UNION ALL SELECT 'data_type' AS category, 'specimens' AS name, count(*) AS total FROM specimens

UNION ALL

SELECT 'source' AS category, sources.name, count(distinct name_id) as total FROM sources
LEFT JOIN datasets ON source_id=sources.id
LEFT JOIN name_attributes ON datasets.id = name_attributes.dataset_id
GROUP BY sources.name

UNION ALL

SELECT 'dataset' AS category, datasets.name, count(*) AS total FROM name_attributes
JOIN datasets ON name_attributes.dataset_id = datasets.id
WHERE name_attributes.name = 'last_updated'
GROUP BY datasets.name;
