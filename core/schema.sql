-- The declarative schema of the ARGA database.
--
-- This is the source of truth and versioned migrations are generated by
-- editing this file and running the atlas tools.


-- PostGIS for geospatial fields. Used for bioregions
CREATE EXTENSION IF NOT EXISTS postgis;


---------------------------
-- Types
---------------------------

CREATE TYPE attribute_category AS ENUM (
    'bushfire_recovery'
);

CREATE TYPE attribute_value_type AS ENUM (
    'boolean',
    'integer',
    'decimal',
    'string',
    'timestamp'
);

CREATE TYPE operation_action AS ENUM (
  'create',
  'update',
  'delete'
);

CREATE TYPE taxonomic_status AS ENUM (
  'accepted',
  'undescribed',
  'species_inquirenda',
  'manuscript_name',
  'hybrid',
  'synonym',
  'unaccepted',
  'informal',
  'placeholder',
  'basionym',
  'nomenclatural_synonym',
  'taxonomic_synonym',
  'replaced_synonym',
  'orthographic_variant',
  'misapplied',
  'excluded',
  'alternative_name',
  'pro_parte_misapplied',
  'pro_parte_taxonomic_synonym',
  'doubtful_misapplied',
  'doubtful_taxonomic_synonym',
  'doubtful_pro_parte_misapplied',
  'doubtful_pro_parte_taxonomic_synonym',
  'taxon_inquirendum',
  'homonym',
  'misspelled',
  'unassessed',
  'unavailable',
  'uncertain',
  'unjustified_emendation',
  'nomen_dubium',
  'nomen_nudum',
  'nomen_oblitum',
  'interim_unpublished',
  'incorrect_grammatical_agreement_of_specific_epithet',
  'superseded_combination',
  'superseded_rank'
);

CREATE TYPE taxonomic_rank AS ENUM (
  'domain',
  'superkingdom',
  'kingdom',
  'subkingdom',
  'phylum',
  'subphylum',
  'superclass',
  'class',
  'subclass',
  'superorder',
  'order',
  'suborder',
  'hyporder',
  'minorder',
  'superfamily',
  'family',
  'subfamily',
  'supertribe',
  'tribe',
  'subtribe',
  'genus',
  'subgenus',
  'higher_taxon',
  'regnum',
  'familia',
  'classis',
  'ordo',
  'varietas',
  'forma',
  'subclassis',
  'superordo',
  'sectio',
  'nothovarietas',
  'subvarietas',
  'series',
  'subfamilia',
  'subordo',
  'regio',
  'species',
  'subspecies',
  'infraspecies',
  'aggregate_genera',
  'aggregate_species',
  'cohort',
  'subcohort',
  'division',
  'infraclass',
  'infraorder',
  'section',
  'subdivision',
  'incertae_sedis',
  'special_form',
  'unranked',
  'subsectio',
  'superspecies',
  'infragenus',
  'subforma',
  'subseries',
  'infrakingdom',
  'superphylum',
  'infraphylum',
  'parvphylum',
  'gigaclass',
  'megaclass',
  'subterclass',
  'parvorder',
  'epifamily',
  'variety',
  'subvariety',
  'natio',
  'mutatio',
  'subsection',
  'pathovar',
  'serovar',
  'biovar',
  'supercohort'
);

CREATE TYPE region_type AS ENUM ('ibra', 'imcra', 'state', 'drainage_basin');

CREATE TYPE nomenclatural_act_type AS ENUM (
  'species_nova',
  'subspecies_nova',
  'genus_species_nova',
  'combinatio_nova',
  'revived_status',
  'name_usage',
  'original_description',
  'redescription',
  'demotion',
  'promotion',
  'synonymisation',
  'heterotypic_synonymy',
  'homotypic_synonymy'
);

CREATE TYPE data_reuse_status as ENUM (
    'limited',
    'unlimited',
    'none',
    'variable'
);

CREATE TYPE access_rights_status as ENUM (
    'open',
    'restricted',
    'conditional',
    'variable'
);

CREATE TYPE source_content_type as ENUM (
    'taxonomic_backbone',
    'ecological_traits',
    'genomic_data',
    'specimens',
    'nongenomic_data',
    'morphological_traits',
    'biochemical_traits',
    'mixed_datatypes',
    'functional_traits',
    'ethnobiology'
);

CREATE TYPE publication_type AS ENUM (
  'book',
  'book_chapter',
  'journal_article',
  'journal_volume',
  'proceedings_paper',
  'url'
);

CREATE TYPE job_status AS ENUM ('pending', 'initialized', 'running', 'completed', 'failed', 'dead');


---------------------------
-- Core tables
---------------------------

-- Dataset collections
CREATE TABLE sources (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    name varchar NOT NULL,
    author varchar NOT NULL,
    rights_holder varchar NOT NULL,
    access_rights varchar NOT NULL,
    license varchar NOT NULL,
    reuse_pill data_reuse_status,
    access_pill access_rights_status,
    content_type source_content_type,
    lists_id varchar(24)
);
COMMENT ON TABLE sources IS 'Metadata of the curated and processed datasets';

CREATE UNIQUE INDEX sources_name ON sources (name);


-- A specific dataset. Used to describe where a specific datum came from
CREATE TABLE datasets (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    source_id uuid REFERENCES sources ON DELETE CASCADE NOT NULL,
    global_id varchar NOT NULL,
    name varchar NOT NULL,
    short_name varchar,
    description text,
    url varchar,
    citation varchar,
    license varchar,
    rights_holder varchar,
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,

    reuse_pill data_reuse_status,
    access_pill access_rights_status,
    publication_year smallint,
    content_type source_content_type
);
COMMENT ON TABLE sources IS 'Information and metadata about imported data';

CREATE UNIQUE INDEX dataset_global_id ON datasets (global_id);


-- A specific version of a dataset. Used in operation logs to identify specific
-- imports of a dataset
CREATE TABLE dataset_versions (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    dataset_id uuid REFERENCES datasets ON DELETE CASCADE NOT NULL,
    version varchar NOT NULL,
    created_at timestamp WITH time zone NOT NULL,
    imported_at timestamp WITH time zone NOT NULL
);

CREATE UNIQUE INDEX dataset_version_dataset_id_created_at ON dataset_versions (dataset_id, created_at);


-- The central names table. Most tables link to this
CREATE TABLE names (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    entity_id bigint,
    scientific_name varchar NOT NULL,
    canonical_name varchar NOT NULL,
    authorship varchar
);
COMMENT ON TABLE names IS 'All taxa names. Unique names used to associate attributes and data for specific taxonomic names';

CREATE UNIQUE INDEX names_scientific_name ON names (scientific_name);
CREATE INDEX names_canonical_name ON names (canonical_name);


-- A publication for any record
CREATE TABLE publications (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    entity_id varchar NOT NULL,

    title varchar,
    authors text[],
    published_year int,
    published_date timestamp with time zone,
    language varchar,
    publisher varchar,
    doi varchar,
    source_urls text[],
    publication_type publication_type,
    citation varchar,

    -- these are timestamps from the dataset, not our own timestamps
    record_created_at timestamp with time zone,
    record_updated_at timestamp with time zone,

    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL
);

-- each entity is a globally unique publication so we ensure that there is only one
-- record that can be reduced from the publication logs
CREATE UNIQUE INDEX publications_entity_id ON publications (entity_id);


-- Agent data. An agent is a person that is referenced in various tables. We want to associate data with
-- and agent via the full name or some other identifier and for that we use our entity hash approach so that
-- lookups aren't necessary when importing.
CREATE TABLE agents (
    entity_id varchar PRIMARY KEY NOT NULL,
    full_name varchar NOT NULL,
    orcid varchar
);


-- Organism data. Referenced by specimens and collection events to determine the 'thing' that has
-- been sampled/collected at a specific instant in time. The organisms table represents the latest version
-- of the record. Should the associated record want an older version of the record then it will also contain
-- an organism_at timestamp as necessary for the operation log facility.
CREATE TABLE organisms (
    entity_id varchar PRIMARY KEY NOT NULL,
    name_id uuid REFERENCES names ON DELETE CASCADE NOT NULL,
    publication_id varchar REFERENCES publications (entity_id),
    organism_id varchar NOT NULL,

    sex varchar,
    genotypic_sex varchar,
    phenotypic_sex varchar,
    life_stage varchar,
    reproductive_condition varchar,
    behavior varchar,
    live_state varchar,
    remarks varchar,

    identified_by varchar REFERENCES agents,
    identification_date date,
    disposition varchar,
    first_observed_at date,
    last_known_alive_at date,

    biome varchar,
    habitat varchar,
    bioregion varchar,
    ibra_imcra varchar,

    latitude float,
    longitude float,
    coordinate_system varchar,
    location_source varchar,
    holding varchar,
    holding_id varchar,
    holding_permit varchar,

    -- these are timestamps from the dataset, not our own timestamps
    record_created_at timestamp with time zone,
    record_updated_at timestamp with time zone,

    created_at timestamp with time zone NOT NULL DEFAULT current_timestamp,
    updated_at timestamp with time zone NOT NULL DEFAULT current_timestamp
);


-- Specimens. A stub table to hang specimen events off. A specimen is anything collected
-- which in turn is anything registered. A specimen always comes from an organism so it's a mandatory
-- reference. A name is also associated for convenience and performance when searching for specimens.
CREATE TABLE specimens (
    entity_id varchar PRIMARY KEY NOT NULL,
    organism_id varchar REFERENCES organisms ON DELETE CASCADE NOT NULL,
    name_id uuid REFERENCES names ON DELETE CASCADE NOT NULL,
    specimen_id varchar
);


-- Tissues. Specimens that are taken from a material sample. Material samples are the output
-- of collection events which are represented as a specimen with a collection event. It is then
-- possible that multiple tissues are extracted from that marterial sample.
CREATE TABLE tissues (
    entity_id varchar PRIMARY KEY NOT NULL,
    specimen_id varchar REFERENCES specimens ON DELETE CASCADE NOT NULL,
    material_sample_id varchar REFERENCES specimens ON DELETE CASCADE NOT NULL,
    tissue_id varchar NOT NULL,
    identification_verified boolean,
    reference_material boolean,
    custodian varchar,
    institution varchar,
    institution_code varchar,
    sampling_protocol varchar,
    tissue_type varchar,
    disposition varchar,
    fixation varchar,
    storage varchar
);

CREATE INDEX tissues_specimen_id ON tissues (specimen_id);
CREATE INDEX tissues_material_sample_id ON tissues (material_sample_id);


-- Subsample data
CREATE TABLE subsamples (
    entity_id varchar PRIMARY KEY NOT NULL,
    specimen_id varchar REFERENCES specimens ON DELETE CASCADE NOT NULL,
    species_name_id bigint NOT NULL,
    publication_id varchar REFERENCES publications (entity_id),
    subsample_id varchar NOT NULL,

    event_date date,
    event_time time,
    sample_type varchar,
    institution_name varchar,
    institution_code varchar,
    name varchar,
    custodian varchar,
    description varchar,
    notes varchar,
    culture_method varchar,
    culture_media varchar,
    weight_or_volume varchar,
    preservation_method varchar,
    preservation_temperature varchar,
    preservation_duration varchar,
    quality varchar,
    cell_type varchar,
    cell_line varchar,
    clone_name varchar,
    lab_host varchar,
    sample_processing varchar,
    sample_pooling varchar
);

CREATE INDEX subsamples_specimen_id ON subsamples (specimen_id);
CREATE INDEX subsamples_species_name_id ON subsamples (species_name_id);


-- DNA extraction data
CREATE TABLE dna_extracts (
    entity_id varchar PRIMARY KEY NOT NULL,
    subsample_id varchar REFERENCES subsamples ON DELETE CASCADE NOT NULL,
    species_name_id bigint NOT NULL,
    publication_id varchar REFERENCES publications (entity_id),
    extract_id varchar NOT NULL,

    event_date date,
    event_time time,
    extracted_by varchar REFERENCES agents,
    material_extracted_by varchar REFERENCES agents,
    nucleic_acid_type varchar,
    preparation_type varchar,
    preservation_type varchar,
    preservation_method varchar,
    extraction_method varchar,
    concentration_method varchar,
    conformation varchar,
    concentration float,
    concentration_unit varchar,
    quantification varchar,
    absorbance_260_230_ratio float,
    absorbance_260_280_ratio float,
    cell_lysis_method varchar,
    action_extracted varchar,
    number_of_extracts_pooled varchar
);

CREATE INDEX dna_extracts_subsample_id ON dna_extracts (subsample_id);
CREATE INDEX dna_extracts_species_name_id ON dna_extracts (species_name_id);


-- Library preparations
CREATE TABLE libraries (
    entity_id varchar PRIMARY KEY NOT NULL,
    extract_id varchar REFERENCES dna_extracts ON DELETE CASCADE NOT NULL,
    species_name_id bigint NOT NULL,
    publication_id varchar REFERENCES publications (entity_id),
    library_id varchar NOT NULL,

    event_date date,
    event_time time,
    prepared_by varchar REFERENCES agents,
    concentration float,
    concentration_unit varchar,
    pcr_cycles int,
    layout varchar,
    selection varchar,
    bait_set_name varchar,
    bait_set_reference varchar,
    construction_protocol varchar,
    source varchar,
    insert_size varchar,
    design_description varchar,
    strategy varchar,
    index_tag varchar,
    index_dual_tag varchar,
    index_oligo varchar,
    index_dual_oligo varchar,
    location varchar,
    remarks varchar,
    dna_treatment varchar,
    number_of_libraries_pooled int,
    pcr_replicates int
);


-- Sequence run data
CREATE TABLE sequence_runs (
    entity_id varchar PRIMARY KEY NOT NULL,
    library_id varchar REFERENCES libraries ON DELETE CASCADE NOT NULL,
    species_name_id bigint NOT NULL,
    publication_id varchar REFERENCES publications (entity_id),
    sequence_run_id varchar NOT NULL,

    event_date date,
    event_time time,
    facility varchar,
    instrument_or_method varchar,
    platform varchar,
    kit_chemistry varchar,
    flowcell_type varchar,
    cell_movie_length varchar,
    base_caller_model varchar,
    fast5_compression varchar,
    analysis_software varchar,
    analysis_software_version varchar,
    target_gene varchar,

    sra_run_accession varchar
);


-- Assembly data
CREATE TABLE assemblies (
    entity_id varchar PRIMARY KEY NOT NULL,
    species_name_id bigint NOT NULL,
    publication_id varchar REFERENCES publications (entity_id),
    assembly_id varchar NOT NULL,

    event_date date,
    event_time time,
    name varchar,
    type varchar,
    level varchar,
    method varchar,
    method_version varchar,
    method_link varchar,
    size bigint,
    size_ungapped bigint,
    minimum_gap_length bigint,
    guanine_cytosine_percent float,
    completeness varchar,
    completeness_method varchar,
    coverage varchar,
    representation varchar,
    source_molecule varchar,
    reference_genome_used varchar,
    reference_genome_link varchar,
    number_of_scaffolds int,
    number_of_contigs int,
    number_of_replicons int,
    hybrid varchar,
    hybrid_information varchar,
    polishing_or_scaffolding_method varchar,
    polishing_or_scaffolding_data varchar,
    computational_infrastructure varchar,
    system_used varchar,
    assembly_n50 varchar
);


-- Library <-> Assembly through table
CREATE TABLE library_assemblies (
    library_entity_id varchar REFERENCES libraries ON DELETE CASCADE NOT NULL,
    assembly_entity_id varchar REFERENCES assemblies ON DELETE CASCADE NOT NULL,
    PRIMARY KEY (library_entity_id, assembly_entity_id)
);

CREATE INDEX library_assemblies_library_entity_id ON library_assemblies (library_entity_id);
CREATE INDEX library_assemblies_assembly_entity_id ON library_assemblies (assembly_entity_id);


-- Data products
CREATE TABLE data_products (
    entity_id varchar PRIMARY KEY NOT NULL,
    publication_id varchar REFERENCES publications (entity_id),
    organism_id varchar REFERENCES organisms (entity_id),
    extract_id varchar REFERENCES dna_extracts (entity_id),
    sequence_run_id varchar REFERENCES sequence_runs (entity_id),
    custodian varchar REFERENCES agents (entity_id),

    sequence_sample_id varchar,
    sequence_analysis_id varchar,
    notes varchar,
    context varchar,
    type varchar,
    file_type varchar,
    url varchar,
    licence varchar,
    access varchar
);


-- Sequence data
CREATE TABLE sequences (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    dataset_id uuid REFERENCES datasets ON DELETE CASCADE NOT NULL,
    name_id uuid REFERENCES names NOT NULL,
    dna_extract_id varchar REFERENCES dna_extracts ON DELETE CASCADE NOT NULL,

    record_id varchar NOT NULL,
    entity_id varchar
);

CREATE INDEX sequences_dataset_id ON sequences (dataset_id);
CREATE INDEX sequences_name_id ON sequences (name_id);
CREATE INDEX sequences_dna_extract_id ON sequences (dna_extract_id);

CREATE UNIQUE INDEX sequences_unique_record_id ON sequences (dataset_id, record_id);


-- Arbitrary attributes associated with a name
CREATE TABLE name_attributes (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    dataset_id uuid REFERENCES datasets NOT NULL,
    name_id uuid REFERENCES names NOT NULL,

    name varchar NOT NULL,
    category attribute_category NOT NULL,
    value_type attribute_value_type NOT NULL,

    value_bool boolean,
    value_int bigint,
    value_decimal decimal,
    value_str varchar,
    value_timestamp timestamp without time zone
);

CREATE UNIQUE INDEX name_attributes_unique_name ON name_attributes (dataset_id, name_id, name);


-- Common names
CREATE TABLE IF NOT EXISTS vernacular_names (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    dataset_id uuid REFERENCES datasets NOT NULL,
    name_id uuid REFERENCES names NOT NULL,
    vernacular_name varchar NOT NULL,
    citation varchar,
    source_url varchar
);

CREATE UNIQUE INDEX IF NOT EXISTS vernacular_names_unique_name ON vernacular_names (dataset_id, name_id, vernacular_name);


-- The taxonomy table. Specifically only stores data for a specific node and links to
-- itself to create a hierarchy. It's possible to create a circular reference, however the
-- views creating a directed acyclic graph will short circuit if a circular reference is
-- detected and treat the last node as a terminus. ie. circular references are safe but
-- probably not what you actually want
CREATE TABLE taxa (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    dataset_id uuid REFERENCES datasets NOT NULL,
    parent_id uuid REFERENCES taxa,

    status taxonomic_status NOT NULL,
    rank taxonomic_rank NOT NULL,

    scientific_name varchar NOT NULL,
    canonical_name varchar NOT NULL,
    authorship varchar,

    nomenclatural_code varchar NOT NULL,
    citation varchar,
    vernacular_names text[],
    description text,
    remarks text,

    created_at timestamp with time zone NOT NULL DEFAULT current_timestamp,
    updated_at timestamp with time zone NOT NULL DEFAULT current_timestamp,
    entity_id varchar
);

CREATE INDEX taxa_parent_id ON taxa (parent_id);
CREATE UNIQUE INDEX taxa_unique_name ON taxa (scientific_name, dataset_id);


-- A through table to link a taxonomy node to multiple variations of a name
CREATE TABLE taxon_names (
    taxon_id uuid REFERENCES taxa NOT NULL,
    name_id uuid REFERENCES names NOT NULL,
    PRIMARY KEY(taxon_id, name_id)
);


-- Photos of a specific taxon
CREATE TABLE taxon_photos (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    taxon_id uuid REFERENCES taxa NOT NULL,
    url varchar NOT NULL,
    source varchar,
    publisher varchar,
    license varchar,
    rights_holder varchar,
    priority int NOT NULL DEFAULT 1
);


-- A name associated with a region
CREATE TABLE regions (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    dataset_id uuid REFERENCES datasets ON DELETE CASCADE NOT NULL,
    name_id uuid REFERENCES names NOT NULL,
    region_type region_type NOT NULL,
    values text[] NOT NULL
);


-- A specific act being made on a name
CREATE TABLE nomenclatural_acts (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),

    entity_id varchar NOT NULL,
    publication_id uuid REFERENCES publications NOT NULL,
    name_id uuid REFERENCES names NOT NULL,
    acted_on_id uuid REFERENCES names NOT NULL,

    act nomenclatural_act_type NOT NULL,
    source_url varchar NOT NULL,

    created_at timestamp with time zone NOT NULL DEFAULT current_timestamp,
    updated_at timestamp with time zone NOT NULL DEFAULT current_timestamp
);
COMMENT ON TABLE nomenclatural_acts IS 'Name definitions and redefinitions. Any act on a name';
COMMENT ON COLUMN nomenclatural_acts.entity_id IS 'The entity in the logs that this record is reduced from';
COMMENT ON COLUMN nomenclatural_acts.name_id IS 'The name that has been defined or changed';
COMMENT ON COLUMN nomenclatural_acts.acted_on_id IS 'The name that is being affected by this act';
COMMENT ON COLUMN nomenclatural_acts.act IS 'The specific act being performed by this record';

CREATE UNIQUE INDEX nomenclatural_acts_entity ON nomenclatural_acts (entity_id);
CREATE INDEX nomenclatural_acts_acted_on ON nomenclatural_acts (acted_on_id);


-- A specific act made within a taxonomic system, such as a synonimisation
CREATE TABLE taxonomic_acts (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),

    entity_id varchar NOT NULL,
    taxon_id uuid REFERENCES taxa NOT NULL,
    accepted_taxon_id uuid REFERENCES taxa,

    source_url varchar,

    created_at timestamp with time zone NOT NULL DEFAULT current_timestamp,
    updated_at timestamp with time zone NOT NULL DEFAULT current_timestamp,
    data_created_at timestamp with time zone,
    data_updated_at timestamp with time zone
);
COMMENT ON TABLE taxonomic_acts IS 'An act within a specific taxonomic system';
COMMENT ON COLUMN taxonomic_acts.entity_id IS 'The entity in the logs that this record is reduced from';
COMMENT ON COLUMN taxonomic_acts.taxon_id IS 'The taxon that is being affected by this act';
COMMENT ON COLUMN taxonomic_acts.accepted_taxon_id IS 'The taxon that is considered currently accepted in the system';

CREATE UNIQUE INDEX taxonomic_acts_unique_entity ON taxonomic_acts (entity_id);
CREATE INDEX taxonomic_acts_unique_taxon ON taxonomic_acts (taxon_id);
CREATE INDEX taxonomic_acts_accepted_taxon ON taxonomic_acts (accepted_taxon_id);


-- The job table for legacy workers
CREATE TABLE jobs (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    status job_status NOT NULL DEFAULT 'pending',
    worker varchar(255) NOT NULL,
    payload jsonb,

    created_at timestamp with time zone NOT NULL DEFAULT current_timestamp,
    updated_at timestamp with time zone NOT NULL DEFAULT current_timestamp
);


-- User table for admin backend
CREATE TABLE users (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    name varchar NOT NULL,
    email varchar NOT NULL UNIQUE,
    user_role varchar NOT NULL,
    password_hash varchar NOT NULL,
    session_id varchar
);


-- Media manually uploaded from the admin portal
CREATE TABLE admin_media (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    name_id uuid REFERENCES names NOT NULL,
    image_source varchar NOT NULL,
    url varchar NOT NULL,
    width integer,
    height integer,
    reference_url varchar,
    title varchar,
    description varchar,
    source varchar,
    creator varchar,
    publisher varchar,
    license varchar,
    rights_holder varchar
);


---------------------------
-- Event tables
---------------------------

-- Collection events
CREATE TABLE collection_events (
    entity_id varchar PRIMARY KEY NOT NULL,
    specimen_id varchar REFERENCES specimens ON DELETE CASCADE NOT NULL,

    name_id uuid REFERENCES names ON DELETE CASCADE NOT NULL,
    organism_id varchar REFERENCES organisms ON DELETE CASCADE NOT NULL,
    material_sample_id varchar,
    field_collecting_id varchar,

    event_date date,
    event_time time without time zone,
    collected_by varchar,
    collection_remarks varchar,
    identified_by varchar,
    identified_date date,
    identification_remarks varchar,

    locality varchar,
    country varchar,
    country_code varchar,
    state_province varchar,
    county varchar,
    municipality varchar,
    latitude float,
    longitude float,
    elevation float,
    depth float,
    elevation_accuracy float,
    depth_accuracy float,
    location_source varchar,

    preparation varchar,
    environment_broad_scale varchar,
    environment_local_scale varchar,
    environment_medium varchar,
    habitat varchar,
    specific_host varchar,
    individual_count varchar,
    organism_quantity varchar,
    organism_quantity_type varchar,

    strain varchar,
    isolate varchar,
    field_notes varchar
);

CREATE INDEX collection_events_specimen_id ON collection_events (specimen_id);
CREATE INDEX collection_events_name_id ON collection_events (name_id);
CREATE INDEX collection_events_organism_id ON collection_events (organism_id);
CREATE INDEX collection_events_field_collecting_id ON collection_events (field_collecting_id);


-- Accession events
CREATE TABLE accession_events (
    entity_id varchar PRIMARY KEY NOT NULL,
    specimen_id varchar REFERENCES specimens ON DELETE CASCADE NOT NULL,

    name_id uuid REFERENCES names ON DELETE CASCADE NOT NULL,

    type_status varchar,
    event_date date,
    event_time time without time zone,

    collection_repository_id varchar,
    collection_repository_code varchar,
    institution_name varchar,
    institution_code varchar,

    disposition varchar,
    preparation varchar,

    accessioned_by varchar,
    prepared_by varchar,
    identified_by varchar,
    identified_date date,
    identification_remarks varchar,

    other_catalog_numbers varchar
);

CREATE INDEX accession_events_specimen_id ON accession_events (specimen_id);
CREATE INDEX accession_events_name_id ON accession_events (name_id);


-- Sequencing event
CREATE TABLE sequencing_events (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    dataset_id uuid REFERENCES datasets ON DELETE CASCADE NOT NULL,
    sequence_id uuid REFERENCES sequences ON DELETE CASCADE NOT NULL,

    event_date varchar,
    event_time varchar,
    sequenced_by varchar,
    material_sample_id varchar,

    concentration float,
    amplicon_size bigint,
    estimated_size varchar,
    bait_set_name varchar,
    bait_set_reference varchar,

    target_gene varchar,
    dna_sequence text,
    entity_id varchar
);

CREATE INDEX sequencing_events_sequence_id ON sequencing_events (sequence_id);


-- Sequencing run event
CREATE TABLE sequencing_run_events (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    sequencing_event_id uuid REFERENCES sequencing_events ON DELETE CASCADE NOT NULL,

    trace_id varchar,
    trace_name varchar,
    trace_link varchar,
    sequencing_date timestamp without time zone,
    sequencing_center varchar,
    sequencing_center_code varchar,
    sequencing_method varchar,

    target_gene varchar,
    direction varchar,
    pcr_primer_name_forward varchar,
    pcr_primer_name_reverse varchar,
    sequence_primer_forward_name varchar,
    sequence_primer_reverse_name varchar,

    library_protocol varchar,
    analysis_description varchar,
    analysis_software varchar,
    entity_id varchar
);

CREATE INDEX sequencing_run_ev_seq_event_id ON sequencing_run_events (sequencing_event_id);


-- Assembly events
CREATE TABLE assembly_events (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    dataset_id uuid REFERENCES datasets ON DELETE CASCADE NOT NULL,
    sequence_id uuid REFERENCES sequences ON DELETE CASCADE NOT NULL,

    event_date varchar,
    event_time varchar,
    assembled_by varchar,

    name varchar,
    version_status varchar,
    quality varchar,
    assembly_type varchar,
    genome_size bigint,
    entity_id varchar
);

CREATE INDEX assembly_events_sequence_id ON assembly_events (sequence_id);


-- Annotation events
CREATE TABLE annotation_events (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    dataset_id uuid REFERENCES datasets ON DELETE CASCADE NOT NULL,
    sequence_id uuid REFERENCES sequences ON DELETE CASCADE NOT NULL,

    event_date varchar,
    event_time varchar,
    annotated_by varchar,

    representation varchar,
    release_type varchar,
    coverage varchar,
    replicons bigint,
    standard_operating_procedures varchar,
    entity_id varchar
);

CREATE INDEX annotation_events_sequence_id ON annotation_events (sequence_id);


-- Deposition events
CREATE TABLE deposition_events (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    dataset_id uuid REFERENCES datasets ON DELETE CASCADE NOT NULL,
    sequence_id uuid REFERENCES sequences ON DELETE CASCADE NOT NULL,

    event_date varchar,
    event_time varchar,
    accession varchar,
    submitted_by varchar,

    material_sample_id varchar,
    collection_name varchar,
    collection_code varchar,
    institution_name varchar,

    data_type varchar,
    excluded_from_refseq varchar,
    asm_not_live_date varchar,
    source_uri varchar,

    title varchar,
    url varchar,
    funding_attribution varchar,
    rights_holder varchar,
    access_rights varchar,
    reference varchar,
    last_updated date,
    entity_id varchar
);

CREATE INDEX deposition_events_sequence_id ON deposition_events (sequence_id);


---------------------------
-- Operation logs
---------------------------

CREATE TABLE nomenclatural_act_logs (
    operation_id numeric PRIMARY KEY NOT NULL,
    parent_id numeric NOT NULL,
    entity_id varchar NOT NULL,
    dataset_version_id uuid REFERENCES dataset_versions ON DELETE CASCADE NOT NULL,
    action operation_action NOT NULL,
    atom jsonb DEFAULT '{}' NOT NULL
);

CREATE INDEX nomenclatural_act_logs_parent_id ON nomenclatural_act_logs (parent_id);
CREATE INDEX nomenclatural_act_logs_entity_id ON nomenclatural_act_logs (entity_id);
CREATE INDEX nomenclatural_act_logs_dataset_version_id ON nomenclatural_act_logs (dataset_version_id);


CREATE TABLE organism_logs (
    operation_id numeric PRIMARY KEY NOT NULL,
    parent_id numeric NOT NULL,
    entity_id varchar NOT NULL,
    dataset_version_id uuid REFERENCES dataset_versions ON DELETE CASCADE NOT NULL,
    action operation_action NOT NULL,
    atom jsonb DEFAULT '{}' NOT NULL
);

CREATE INDEX organism_logs_parent_id ON organism_logs (parent_id);
CREATE INDEX organism_logs_entity_id ON organism_logs (entity_id);
CREATE INDEX organism_logs_dataset_version_id ON organism_logs (dataset_version_id);


CREATE TABLE specimen_logs (
    operation_id numeric PRIMARY KEY NOT NULL,
    parent_id numeric NOT NULL,
    entity_id varchar NOT NULL,
    dataset_version_id uuid REFERENCES dataset_versions ON DELETE CASCADE NOT NULL,
    action operation_action NOT NULL,
    atom jsonb DEFAULT '{}' NOT NULL
);

CREATE INDEX specimen_logs_parent_id ON specimen_logs (parent_id);
CREATE INDEX specimen_logs_entity_id ON specimen_logs (entity_id);
CREATE INDEX specimen_logs_dataset_version_id ON specimen_logs (dataset_version_id);


CREATE TABLE tissue_logs (
    operation_id numeric PRIMARY KEY NOT NULL,
    parent_id numeric NOT NULL,
    entity_id varchar NOT NULL,
    dataset_version_id uuid REFERENCES dataset_versions ON DELETE CASCADE NOT NULL,
    action operation_action NOT NULL,
    atom jsonb DEFAULT '{}' NOT NULL
);

CREATE INDEX tissue_logs_parent_id ON tissue_logs (parent_id);
CREATE INDEX tissue_logs_entity_id ON tissue_logs (entity_id);
CREATE INDEX tissue_logs_dataset_version_id ON tissue_logs (dataset_version_id);


CREATE TABLE library_logs (
    operation_id numeric PRIMARY KEY NOT NULL,
    parent_id numeric NOT NULL,
    entity_id varchar NOT NULL,
    dataset_version_id uuid REFERENCES dataset_versions ON DELETE CASCADE NOT NULL,
    action operation_action NOT NULL,
    atom jsonb DEFAULT '{}' NOT NULL
);

CREATE INDEX library_logs_parent_id ON library_logs (parent_id);
CREATE INDEX library_logs_entity_id ON library_logs (entity_id);
CREATE INDEX library_logs_dataset_version_id ON library_logs (dataset_version_id);


CREATE TABLE sequence_run_logs (
    operation_id numeric PRIMARY KEY NOT NULL,
    parent_id numeric NOT NULL,
    entity_id varchar NOT NULL,
    dataset_version_id uuid REFERENCES dataset_versions ON DELETE CASCADE NOT NULL,
    action operation_action NOT NULL,
    atom jsonb DEFAULT '{}' NOT NULL
);

CREATE INDEX sequence_run_logs_parent_id ON sequence_run_logs (parent_id);
CREATE INDEX sequence_run_logs_entity_id ON sequence_run_logs (entity_id);
CREATE INDEX sequence_run_logs_dataset_version_id ON sequence_run_logs (dataset_version_id);


CREATE TABLE assembly_logs (
    operation_id numeric PRIMARY KEY NOT NULL,
    parent_id numeric NOT NULL,
    entity_id varchar NOT NULL,
    dataset_version_id uuid REFERENCES dataset_versions ON DELETE CASCADE NOT NULL,
    action operation_action NOT NULL,
    atom jsonb DEFAULT '{}' NOT NULL
);

CREATE INDEX assembly_logs_parent_id ON assembly_logs (parent_id);
CREATE INDEX assembly_logs_entity_id ON assembly_logs (entity_id);
CREATE INDEX assembly_logs_dataset_version_id ON assembly_logs (dataset_version_id);


CREATE TABLE data_product_logs (
    operation_id numeric PRIMARY KEY NOT NULL,
    parent_id numeric NOT NULL,
    entity_id varchar NOT NULL,
    dataset_version_id uuid REFERENCES dataset_versions ON DELETE CASCADE NOT NULL,
    action operation_action NOT NULL,
    atom jsonb DEFAULT '{}' NOT NULL
);

CREATE INDEX data_product_logs_parent_id ON data_product_logs (parent_id);
CREATE INDEX data_product_logs_entity_id ON data_product_logs (entity_id);
CREATE INDEX data_product_logs_dataset_version_id ON data_product_logs (dataset_version_id);



CREATE TABLE collection_event_logs (
    operation_id numeric PRIMARY KEY NOT NULL,
    parent_id numeric NOT NULL,
    entity_id varchar NOT NULL,
    dataset_version_id uuid REFERENCES dataset_versions ON DELETE CASCADE NOT NULL,
    action operation_action NOT NULL,
    atom jsonb DEFAULT '{}' NOT NULL
);

CREATE INDEX collection_event_logs_parent_id ON collection_event_logs (parent_id);
CREATE INDEX collection_event_logs_entity_id ON collection_event_logs (entity_id);
CREATE INDEX collection_event_logs_dataset_version_id ON collection_event_logs (dataset_version_id);


CREATE TABLE accession_event_logs (
    operation_id numeric PRIMARY KEY NOT NULL,
    parent_id numeric NOT NULL,
    entity_id varchar NOT NULL,
    dataset_version_id uuid REFERENCES dataset_versions ON DELETE CASCADE NOT NULL,
    action operation_action NOT NULL,
    atom jsonb DEFAULT '{}' NOT NULL
);

CREATE INDEX accession_event_logs_parent_id ON accession_event_logs (parent_id);
CREATE INDEX accession_event_logs_entity_id ON accession_event_logs (entity_id);
CREATE INDEX accession_event_logs_dataset_version_id ON accession_event_logs (dataset_version_id);


CREATE TABLE subsample_logs (
    operation_id numeric PRIMARY KEY NOT NULL,
    parent_id numeric NOT NULL,
    entity_id varchar NOT NULL,
    dataset_version_id uuid REFERENCES dataset_versions ON DELETE CASCADE NOT NULL,
    action operation_action NOT NULL,
    atom jsonb DEFAULT '{}' NOT NULL
);

CREATE INDEX subsample_logs_parent_id ON subsample_logs (parent_id);
CREATE INDEX subsample_logs_entity_id ON subsample_logs (entity_id);
CREATE INDEX subsample_logs_dataset_version_id ON subsample_logs (dataset_version_id);


CREATE TABLE extraction_logs (
    operation_id numeric PRIMARY KEY NOT NULL,
    parent_id numeric NOT NULL,
    entity_id varchar NOT NULL,
    dataset_version_id uuid REFERENCES dataset_versions ON DELETE CASCADE NOT NULL,
    action operation_action NOT NULL,
    atom jsonb DEFAULT '{}' NOT NULL
);

CREATE INDEX extraction_logs_parent_id ON extraction_logs (parent_id);
CREATE INDEX extraction_logs_entity_id ON extraction_logs (entity_id);
CREATE INDEX extraction_logs_dataset_version_id ON extraction_logs (dataset_version_id);


CREATE TABLE taxa_logs (
    operation_id numeric PRIMARY KEY NOT NULL,
    parent_id numeric NOT NULL,
    entity_id varchar NOT NULL,
    dataset_version_id uuid REFERENCES dataset_versions ON DELETE CASCADE NOT NULL,
    action operation_action NOT NULL,
    atom jsonb DEFAULT '{}' NOT NULL
);

CREATE INDEX taxa_logs_parent_id ON taxa_logs (parent_id);
CREATE INDEX taxa_logs_entity_id ON taxa_logs (entity_id);
CREATE INDEX taxa_logs_dataset_version_id ON taxa_logs (dataset_version_id);


CREATE TABLE taxonomic_act_logs (
    operation_id numeric PRIMARY KEY NOT NULL,
    parent_id numeric NOT NULL,
    entity_id varchar NOT NULL,
    dataset_version_id uuid REFERENCES dataset_versions ON DELETE CASCADE NOT NULL,
    action operation_action NOT NULL,
    atom jsonb DEFAULT '{}' NOT NULL
);

CREATE INDEX taxonomic_act_logs_parent_id ON taxonomic_act_logs (parent_id);
CREATE INDEX taxonomic_act_logs_entity_id ON taxonomic_act_logs (entity_id);
CREATE INDEX taxonomic_act_logs_dataset_version_id ON taxonomic_act_logs (dataset_version_id);


CREATE TABLE sequence_logs (
    operation_id numeric PRIMARY KEY NOT NULL,
    parent_id numeric NOT NULL,
    entity_id varchar NOT NULL,
    dataset_version_id uuid REFERENCES dataset_versions ON DELETE CASCADE NOT NULL,
    action operation_action NOT NULL,
    atom jsonb DEFAULT '{}' NOT NULL
);

CREATE INDEX sequence_logs_parent_id ON sequence_logs (parent_id);
CREATE INDEX sequence_logs_entity_id ON sequence_logs (entity_id);
CREATE INDEX sequence_logs_dataset_version_id ON sequence_logs (dataset_version_id);


CREATE TABLE publication_logs (
    operation_id numeric PRIMARY KEY NOT NULL,
    parent_id numeric NOT NULL,
    entity_id varchar NOT NULL,
    dataset_version_id uuid REFERENCES dataset_versions ON DELETE CASCADE NOT NULL,
    action operation_action NOT NULL,
    atom jsonb DEFAULT '{}' NOT NULL
);

CREATE INDEX publication_logs_parent_id ON publication_logs (parent_id);
CREATE INDEX publication_logs_entity_id ON publication_logs (entity_id);
CREATE INDEX publication_logs_dataset_version_id ON publication_logs (dataset_version_id);


CREATE TABLE agent_logs (
    operation_id numeric PRIMARY KEY NOT NULL,
    parent_id numeric NOT NULL,
    entity_id varchar NOT NULL,
    dataset_version_id uuid REFERENCES dataset_versions ON DELETE CASCADE NOT NULL,
    action operation_action NOT NULL,
    atom jsonb DEFAULT '{}' NOT NULL
);

CREATE INDEX agent_logs_parent_id ON agent_logs (parent_id);
CREATE INDEX agent_logs_entity_id ON agent_logs (entity_id);
CREATE INDEX agent_logs_dataset_version_id ON agent_logs (dataset_version_id);


---------------------------
-- Region tables
---------------------------

-- Interim Biogeographic Regionalisation for Australia
CREATE TABLE ibra (
    ogc_fid integer PRIMARY KEY,
    reg_code_7 character varying,
    reg_name_7 character varying,
    hectares double precision,
    sq_km double precision,
    rec_id integer,
    reg_code_6 character varying,
    reg_name_6 character varying,
    reg_no_61 double precision,
    feat_id character varying,
    shape_leng double precision,
    shape_area double precision,
    wkb_geometry geometry(MultiPolygon,4283)
);

CREATE INDEX ibra_wkb_geometry_geom_idx ON ibra USING gist (wkb_geometry);


-- Integrated Marine and Coastal Regionalisation of Australia
CREATE TABLE imcra_provincial (
    ogc_fid integer PRIMARY KEY,
    pb_name varchar,
    pb_num integer,
    water_type varchar,
    area_km2 double precision,
    wkb_geometry geometry(MultiPolygon, 4283)
);

CREATE INDEX imcra_provincial_wkb_geometry_geom_idx ON imcra_provincial USING gist (wkb_geometry);


CREATE TABLE imcra_mesoscale (
    ogc_fid integer PRIMARY KEY,
    meso_name varchar,
    meso_num integer,
    meso_abbr varchar,
    water_type varchar,
    area_km2 double precision,
    wkb_geometry geometry(MultiPolygon, 4283)
);

CREATE INDEX imcra_mesoscale_wkb_geometry_geom_idx ON imcra_mesoscale USING gist (wkb_geometry);


---------------------------
-- Views
---------------------------

-- a convenience view that joins all the sequencing events. Will return duplicates of
-- a sequence if there are multiple events of the same type for a sequence
CREATE VIEW whole_genomes AS
SELECT
    sequences.id AS sequence_id,
    sequences.dataset_id,
    sequences.name_id,
    sequences.dna_extract_id,
    datasets.name AS dataset_name,
    sequences.record_id,
    collection_events.latitude,
    collection_events.longitude,
    deposition_events.accession,
    sequencing_events.sequenced_by,
    sequencing_events.material_sample_id,
    sequencing_events.estimated_size,
    assembly_events.assembled_by,
    assembly_events.name,
    assembly_events.version_status,
    assembly_events.quality,
    assembly_events.assembly_type,
    assembly_events.genome_size,
    annotation_events.annotated_by,
    annotation_events.representation,
    annotation_events.release_type,
    deposition_events.event_date AS release_date,
    deposition_events.submitted_by AS deposited_by,
    deposition_events.data_type,
    deposition_events.excluded_from_refseq
FROM sequences
JOIN datasets ON sequences.dataset_id = datasets.id
JOIN sequencing_events ON sequences.id = sequencing_events.sequence_id
JOIN assembly_events ON sequences.id = assembly_events.sequence_id
JOIN annotation_events ON sequences.id = annotation_events.sequence_id
JOIN deposition_events ON sequences.id = deposition_events.sequence_id
LEFT JOIN dna_extracts ON sequences.dna_extract_id = dna_extracts.entity_id
LEFT JOIN subsamples ON dna_extracts.subsample_id = subsamples.entity_id
LEFT JOIN specimens ON subsamples.specimen_id = specimens.entity_id
LEFT JOIN collection_events ON specimens.entity_id = collection_events.specimen_id;


-- All loci data
CREATE VIEW markers AS
SELECT DISTINCT
    sequences.id AS sequence_id,
    sequences.dataset_id,
    sequences.name_id,
    sequences.dna_extract_id,
    datasets.name AS dataset_name,
    sequences.record_id,
    collection_events.latitude,
    collection_events.longitude,
    deposition_events.accession,
    sequencing_events.sequenced_by,
    sequencing_events.material_sample_id,
    sequencing_events.target_gene,
    deposition_events.event_date AS release_date
FROM sequences
JOIN datasets ON sequences.dataset_id = datasets.id
JOIN sequencing_events ON sequences.id = sequencing_events.sequence_id
LEFT JOIN deposition_events ON sequences.id = deposition_events.sequence_id
LEFT JOIN dna_extracts ON sequences.dna_extract_id = dna_extracts.entity_id
LEFT JOIN subsamples ON dna_extracts.subsample_id = subsamples.entity_id
LEFT JOIN specimens ON subsamples.specimen_id = specimens.entity_id
LEFT JOIN collection_events ON specimens.entity_id = collection_events.specimen_id
WHERE sequencing_events.target_gene IS NOT NULL;


-- All data regarded as a genomic component
CREATE VIEW genomic_components AS
SELECT DISTINCT
    sequences.id AS sequence_id,
    sequences.dataset_id,
    sequences.name_id,
    sequences.dna_extract_id,
    datasets.name AS dataset_name,
    sequences.record_id,
    collection_events.latitude,
    collection_events.longitude,
    deposition_events.accession,
    sequencing_events.sequenced_by,
    sequencing_events.material_sample_id,
    sequencing_events.estimated_size,
    deposition_events.event_date AS release_date,
    deposition_events.submitted_by AS deposited_by,
    deposition_events.data_type,
    deposition_events.title,
    deposition_events.url,
    deposition_events.source_uri,
    deposition_events.funding_attribution,
    deposition_events.rights_holder,
    deposition_events.access_rights
FROM sequences
JOIN datasets ON sequences.dataset_id = datasets.id
JOIN sequencing_events ON sequences.id = sequencing_events.sequence_id
JOIN deposition_events ON sequences.id = deposition_events.sequence_id
LEFT JOIN assembly_events on sequences.id = assembly_events.sequence_id
LEFT JOIN dna_extracts ON sequences.dna_extract_id = dna_extracts.entity_id
LEFT JOIN subsamples ON dna_extracts.subsample_id = subsamples.entity_id
LEFT JOIN specimens ON subsamples.specimen_id = specimens.entity_id
LEFT JOIN collection_events ON specimens.entity_id = collection_events.specimen_id
WHERE assembly_events.id IS NULL AND target_gene IS NULL;


---------------------------
-- Materialized views
---------------------------

-- The earliest dates for specific events within a sequence
CREATE MATERIALIZED VIEW sequence_milestones AS
SELECT
    sequences.name_id,
    annotation_events.representation,
    MIN(sequencing_events.event_date) AS sequencing_date,
    MIN(assembly_events.event_date) AS assembly_date,
    MIN(annotation_events.event_date) AS annotation_date,
    MIN(deposition_events.event_date) AS deposition_date
FROM sequences
JOIN sequencing_events ON sequences.id = sequencing_events.sequence_id
JOIN assembly_events ON sequences.id = assembly_events.sequence_id
JOIN annotation_events ON sequences.id = annotation_events.sequence_id
JOIN deposition_events ON sequences.id = deposition_events.sequence_id
JOIN taxon_names ON sequences.name_id = taxon_names.name_id
GROUP BY sequences.name_id, representation;

CREATE UNIQUE INDEX sequence_milestones_name_representation ON sequence_milestones (name_id, representation);


-- Stats for data linked to a name
CREATE MATERIALIZED VIEW name_data_summaries AS
SELECT
    names.id AS name_id,
    COALESCE(markers.total, 0) AS markers,
    COALESCE(genomes.total, 0) AS genomes,
    COALESCE(specimens.total, 0) AS specimens,
    COALESCE(other_data.total, 0) AS other,
    COALESCE(markers.total, 0) + COALESCE(genomes.total, 0) + COALESCE(other_data.total, 0) AS total_genomic,

    COALESCE(full_genomes.total, 0) AS full_genomes,
    COALESCE(partial_genomes.total, 0) AS partial_genomes,
    COALESCE(complete_genomes.total, 0) AS complete_genomes,
    COALESCE(assembly_chromosomes.total, 0) AS assembly_chromosomes,
    COALESCE(assembly_scaffolds.total, 0) AS assembly_scaffolds,
    COALESCE(assembly_contigs.total, 0) AS assembly_contigs
FROM names
LEFT JOIN (
     SELECT name_id, count(*)::int AS total
     FROM sequencing_events
     JOIN sequences ON sequencing_events.sequence_id = sequences.id
     WHERE target_gene IS NOT NULL
     GROUP BY name_id
) markers ON markers.name_id = names.id

LEFT JOIN (
     SELECT name_id, count(*)::int AS total
     FROM assembly_events
     JOIN sequences ON assembly_events.sequence_id = sequences.id
     GROUP BY name_id
) genomes ON genomes.name_id = names.id

LEFT JOIN (
     SELECT name_id, count(*)::int AS total
     FROM specimens
     GROUP BY name_id
) specimens ON specimens.name_id = names.id

LEFT JOIN (
     SELECT name_id, count(*)::int as total
     FROM sequences
     LEFT JOIN sequencing_events se on sequences.id = se.sequence_id
     LEFT JOIN assembly_events on sequences.id = assembly_events.sequence_id
     LEFT JOIN annotation_events ae on sequences.id = ae.sequence_id
     WHERE assembly_events.id IS NULL AND target_gene IS NULL
     GROUP BY name_id
) other_data ON other_data.name_id = names.id

LEFT JOIN (
     SELECT name_id, count(*)::int AS total
     FROM annotation_events
     JOIN sequences ON annotation_events.sequence_id = sequences.id
     WHERE representation = 'Full'
     GROUP BY name_id
) full_genomes ON full_genomes.name_id = names.id

LEFT JOIN (
     SELECT name_id, count(*)::int AS total
     FROM annotation_events
     JOIN sequences ON annotation_events.sequence_id = sequences.id
     WHERE representation = 'Partial'
     GROUP BY name_id
) partial_genomes ON partial_genomes.name_id = names.id

LEFT JOIN (
     SELECT name_id, count(*)::int AS total
     FROM assembly_events
     JOIN sequences ON assembly_events.sequence_id = sequences.id
     WHERE quality = 'Complete Genome'
     GROUP BY name_id
) complete_genomes ON complete_genomes.name_id = names.id

LEFT JOIN (
     SELECT name_id, count(*)::int AS total
     FROM assembly_events
     JOIN sequences ON assembly_events.sequence_id = sequences.id
     WHERE quality = 'Chromosome'
     GROUP BY name_id
) assembly_chromosomes ON assembly_chromosomes.name_id = names.id

LEFT JOIN (
     SELECT name_id, count(*)::int AS total
     FROM assembly_events
     JOIN sequences ON assembly_events.sequence_id = sequences.id
     WHERE quality = 'Scaffold'
     GROUP BY name_id
) assembly_scaffolds ON assembly_scaffolds.name_id = names.id

LEFT JOIN (
     SELECT name_id, count(*)::int AS total
     FROM assembly_events
     JOIN sequences ON assembly_events.sequence_id = sequences.id
     WHERE quality = 'Contig'
     GROUP BY name_id
) assembly_contigs ON assembly_contigs.name_id = names.id;

CREATE UNIQUE INDEX name_data_summaries_name_id ON name_data_summaries (name_id);


-- The primary taxonomy graph. This is a denormalised version of the taxa table
-- which allows us to retrieve the hierarchy of a specific node
CREATE MATERIALIZED VIEW taxa_dag AS
WITH RECURSIVE dag(
    taxon_id,
    taxon_scientific_name,
    taxon_canonical_name,
    id,
    parent_id,
    rank,
    scientific_name,
    canonical_name,
    depth,
    is_cycle,
    path
) AS (
    SELECT
        id AS taxon_id,
        scientific_name AS taxon_scientific_name,
        canonical_name AS taxon_canonical_name,
        id,
        parent_id,
        rank,
        scientific_name,
        canonical_name,
        0,
        false,
        ARRAY[id]
    FROM taxa
UNION
    SELECT
        dag.taxon_id,
        dag.taxon_scientific_name,
        dag.taxon_canonical_name,
        t.id,
        t.parent_id,
        t.rank,
        t.scientific_name,
        t.canonical_name,
        dag.depth + 1,
        t.id = ANY(path),
        path || t.id
    FROM dag, taxa t
    WHERE dag.parent_id = t.id
      AND dag.id != dag.parent_id
      AND dag.parent_id IS NOT NULL
      AND NOT is_cycle
)
SELECT taxon_id, taxon_scientific_name, taxon_canonical_name, id, parent_id, rank, scientific_name, canonical_name, depth
FROM dag
ORDER BY taxon_id ASC, depth ASC;

CREATE INDEX taxa_dag_id ON taxa_dag (taxon_id);
CREATE UNIQUE INDEX taxa_dag_id_taxon_id ON taxa_dag (id, taxon_id);


-- A taxonomy graph derived from taxa_dag to allow querying for all descendants of a specific
-- taxon node
CREATE MATERIALIZED VIEW taxa_dag_down AS
WITH RECURSIVE dag(
    taxon_id,
    id,
    parent_id,
    depth,
    is_cycle,
    path
) AS (
    SELECT
        id AS taxon_id,
        id,
        parent_id,
        0,         -- depth
        false,     -- is_cycle
        ARRAY[id]  -- path
    FROM taxa
UNION
    -- for each row that the intermediate table spits out we join
    -- on all taxa that has a parent_id matching the rows that were output.
    -- this lets us go down the tree as each time we will output more rows
    -- until we reach the leafs (the row has no other rows linking to it via parent_id).
    SELECT
        dag.taxon_id,
        t.id,
        t.parent_id,
        dag.depth + 1,     -- depth
        t.id = ANY(path),  -- is_cycle
        path || t.id       -- path
    FROM dag, taxa t
    WHERE dag.id = t.parent_id
      -- because we are traversing down the tree we don't need to check for a terminus such as a parent
      -- null check. instead we just want to make sure we aren't infinitely trying to traverse the root
      -- so we only do a cyclic check.
      AND NOT is_cycle
)
SELECT taxon_id, id, parent_id, depth
FROM dag
ORDER BY taxon_id ASC, depth ASC;

COMMENT ON MATERIALIZED VIEW taxa_dag_down IS 'A denormalised graph of all descendents for every taxon';

-- index on the 'query' column. this is how most queries are going to hit the view. specifically to get a list of
-- descendant nodes for a particular taxon
CREATE INDEX taxa_dag_down_taxon_id ON taxa_dag_down (taxon_id);

-- because the underlying taxa tree is a DAG we know that a taxon can only ever appear once for each taxon_id 'query'.
-- by creating a uniqueness constraint on taxon_id and id we can concurrently update the tree without locking the table
CREATE UNIQUE INDEX taxa_dag_down_taxon_id_id ON taxa_dag_down (taxon_id, id, depth);


-- A full, denormalised, taxonomic tree
CREATE MATERIALIZED VIEW taxa_tree AS
WITH RECURSIVE tree (
    taxon_id,
    path_id,
    id,
    parent_id,
    depth,
    path
) AS (
    SELECT
        taxon_id,
        id AS path_id,
        id,
        parent_id,
        0,
        ARRAY[id]
    FROM taxa_dag_down
UNION
    SELECT
        tree.taxon_id,
        tree.path_id,
        t.id,
        t.parent_id,
        tree.depth + 1,
        path || t.id
    FROM tree, taxa t
    WHERE tree.parent_id = t.id
    AND NOT tree.taxon_id = ANY(path)
)
SELECT taxon_id, path_id, id, parent_id, depth
FROM tree
ORDER BY path_id, depth DESC;

COMMENT ON MATERIALIZED VIEW taxa_tree IS 'A denormalised, exhaustive tree containing all paths that descend from every taxon';
COMMENT ON COLUMN taxa_tree.taxon_id IS 'The root taxon that a descending tree is available for';
COMMENT ON COLUMN taxa_tree.path_id IS 'The taxon that this particular path starts from';

CREATE INDEX taxa_tree_taxon_id ON taxa_tree (taxon_id);
CREATE INDEX taxa_tree_path_id ON taxa_tree (path_id);
CREATE UNIQUE INDEX taxa_tree_taxon_id_path_id ON taxa_tree (taxon_id, path_id, depth);


-- Accumulated stats for every node in a taxonomic tree. This will aggregate statistics going
-- so that each node stat is an aggregation of all descendant node stats
CREATE MATERIALIZED VIEW taxa_tree_stats AS
-- combines the name_data_summaries of names that are linked to one another.
-- this allows us to present data from dark taxa
WITH taxa_data_summaries AS (
     SELECT
        taxon_id,
        SUM(markers) AS loci,
        SUM(genomes) AS genomes,
        SUM(specimens) AS specimens,
        SUM(other) AS other,
        SUM(total_genomic) AS total_genomic,

        SUM(full_genomes) AS full_genomes,
        SUM(partial_genomes) AS partial_genomes,
        SUM(complete_genomes) AS complete_genomes,
        SUM(assembly_chromosomes) AS assembly_chromosomes,
        SUM(assembly_scaffolds) AS assembly_scaffolds,
        SUM(assembly_contigs) AS assembly_contigs
    FROM name_data_summaries
    JOIN taxon_names ON taxon_names.name_id = name_data_summaries.name_id
    GROUP BY taxon_id
),
-- the linked name_data_summaries joined with the taxa_tree to get stats that
-- aggregate up the taxa hierarchy for each taxon
taxon_stats AS (
    SELECT
        taxa_tree.taxon_id,
        id,
        path_id,
        depth,
        -- if the node is the second taxon in the path then its the direct parent of
        -- leaf node, so we use the value of 1 to allow summing when grouped. this allows
        -- us to determine how many direct children each node has
        CASE WHEN depth = 1 THEN 1 ELSE 0 END AS direct_parent,
        -- pull the the values from the name data summaries
        FIRST_VALUE(loci) OVER tree_paths AS loci,
        FIRST_VALUE(genomes) OVER tree_paths AS genomes,
        FIRST_VALUE(specimens) OVER tree_paths AS specimens,
        FIRST_VALUE(other) OVER tree_paths AS other,
        FIRST_VALUE(total_genomic) OVER tree_paths AS total_genomic,
        FIRST_VALUE(full_genomes) OVER tree_paths AS full_genomes,
        FIRST_VALUE(partial_genomes) OVER tree_paths AS partial_genomes,
        FIRST_VALUE(complete_genomes) OVER tree_paths AS complete_genomes,
        FIRST_VALUE(assembly_chromosomes) OVER tree_paths AS assembly_chromosomes,
        FIRST_VALUE(assembly_scaffolds) OVER tree_paths AS assembly_scaffolds,
        FIRST_VALUE(assembly_contigs) OVER tree_paths AS assembly_contigs,
        -- base values for coverage stats. if there is at least one type of data we consider
        -- it full coverage for the node. this is useful further on when summarising a node
        -- and comparing the total coverage against the amount of children to determine coverage
        -- for a node at any part of the hierarchy without losing that information to aggregation
        CASE WHEN FIRST_VALUE(full_genomes) OVER tree_paths > 0 THEN 1 ELSE 0 END AS full_genomes_coverage,
        CASE WHEN FIRST_VALUE(partial_genomes) OVER tree_paths > 0 THEN 1 ELSE 0 END AS partial_genomes_coverage,
        CASE WHEN FIRST_VALUE(complete_genomes) OVER tree_paths > 0 THEN 1 ELSE 0 END AS complete_genomes_coverage,
        CASE WHEN FIRST_VALUE(assembly_chromosomes) OVER tree_paths > 0 THEN 1 ELSE 0 END AS assembly_chromosomes_coverage,
        CASE WHEN FIRST_VALUE(assembly_scaffolds) OVER tree_paths > 0 THEN 1 ELSE 0 END AS assembly_scaffolds_coverage,
        CASE WHEN FIRST_VALUE(assembly_contigs) OVER tree_paths > 0 THEN 1 ELSE 0 END AS assembly_contigs_coverage
    FROM taxa_tree
    -- a taxon can have multiple alternate names so we group them
    -- up and sum it here otherwise it will cause double counting
    LEFT JOIN taxa_data_summaries ON taxa_data_summaries.taxon_id = taxa_tree.id
    WINDOW tree_paths AS (partition BY path_id ORDER BY depth)
    ORDER BY path_id, depth
),
-- the grouped up stats for higher taxonomy. it joins the taxon_stats on the
-- path_id to get the accumulated amounts of all descendents and then groups
-- by the taxon id itself to ensure that all paths are folded in to the parent taxon
stats AS (
    SELECT
        taxon_id,
        taxon_stats.id,
        MAX(depth) AS tree_depth,
        SUM(direct_parent) AS children,
        COUNT(*) - 1 AS descendants,
        SUM(loci) AS loci,
        SUM(genomes) AS genomes,
        SUM(specimens) AS specimens,
        SUM(other) AS other,
        SUM(total_genomic) AS total_genomic,
        SUM(CASE WHEN taxa.rank='species' THEN 1 ELSE 0 END) AS species,
        SUM(full_genomes) AS full_genomes,
        SUM(partial_genomes) AS partial_genomes,
        SUM(complete_genomes) AS complete_genomes,
        SUM(assembly_chromosomes) AS assembly_chromosomes,
        SUM(assembly_scaffolds) AS assembly_scaffolds,
        SUM(assembly_contigs) AS assembly_contigs,
        -- sum up all the coverage for the node and divide it by the amount of children to determine
        -- the total coverage for this specific node.
        --
        -- we want to also clamp the coverage if we are a species node so that the coverage effectively
        -- has a resolution of species and not subspecies or varieties. this is largely a practical matter
        -- as the stability of the tree is much greater at the species level compared to the ranks beneath it
        LEAST(SUM(full_genomes_coverage), SUM(CASE WHEN taxa.rank='species' THEN 1 ELSE 0 END)) AS total_full_genomes_coverage,
        LEAST(SUM(partial_genomes_coverage), SUM(CASE WHEN taxa.rank='species' THEN 1 ELSE 0 END)) AS total_partial_genomes_coverage,
        LEAST(SUM(complete_genomes_coverage), SUM(CASE WHEN taxa.rank='species' THEN 1 ELSE 0 END)) AS total_complete_genomes_coverage,
        LEAST(SUM(assembly_chromosomes_coverage), SUM(CASE WHEN taxa.rank='species' THEN 1 ELSE 0 END)) AS total_assembly_chromosomes_coverage,
        LEAST(SUM(assembly_scaffolds_coverage), SUM(CASE WHEN taxa.rank='species' THEN 1 ELSE 0 END)) AS total_assembly_scaffolds_coverage,
        LEAST(SUM(assembly_contigs_coverage), SUM(CASE WHEN taxa.rank='species' THEN 1 ELSE 0 END)) AS total_assembly_contigs_coverage
    FROM taxon_stats
    JOIN taxa ON taxon_stats.path_id = taxa.id
    GROUP BY taxon_id, taxon_stats.id
)
-- the main query. simply join the tree stats with the taxon and sum the stats for each node
SELECT * FROM stats;

CREATE INDEX taxa_tree_stats_taxon_id ON taxa_tree_stats (taxon_id);
CREATE INDEX taxa_tree_stats_id ON taxa_tree_stats (id);
CREATE UNIQUE INDEX taxa_tree_stats_id_taxon_id ON taxa_tree_stats (id, taxon_id);


-- All species with associated data
CREATE MATERIALIZED VIEW species AS
SELECT
    taxa.id,
    taxa.scientific_name,
    taxa.canonical_name,
    taxa.authorship,
    taxa.dataset_id,
    taxa.status,
    taxa.rank,
    taxa_tree.classification,
    summaries.genomes,
    summaries.loci,
    summaries.specimens,
    summaries.other,
    summaries.total_genomic,
    name_attributes.traits,
    name_attributes.attributes,
    vernacular_names.names AS vernacular_names
FROM taxa
JOIN (
  SELECT
      taxon_id,
      jsonb_object_agg(rank, canonical_name) AS classification
  FROM taxa_dag
  GROUP BY taxon_id
) taxa_tree ON taxa.parent_id = taxa_tree.taxon_id
JOIN (
  SELECT
      taxon_id,
      SUM(genomes) AS genomes,
      SUM(markers) AS loci,
      SUM(specimens) AS specimens,
      SUM(other) AS other,
      SUM(total_genomic) AS total_genomic
  FROM name_data_summaries
  JOIN taxon_names ON taxon_names.name_id = name_data_summaries.name_id
  GROUP BY taxon_id
) summaries ON taxa.id = summaries.taxon_id
LEFT JOIN (
  SELECT
    taxon_id,
    array_agg(name::text) filter (WHERE value_type = 'boolean') AS traits,
    jsonb_agg(CASE
     WHEN value_type = 'boolean' THEN jsonb_build_object('name', name, 'value', value_bool)
     WHEN value_type = 'string' THEN jsonb_build_object('name', name, 'value', value_str)
     WHEN value_type = 'integer' THEN jsonb_build_object('name', name, 'value', value_int)
     WHEN value_type = 'decimal' THEN jsonb_build_object('name', name, 'value', value_decimal)
     WHEN value_type = 'timestamp' THEN jsonb_build_object('name', name, 'value', value_timestamp)
    END) AS attributes
  FROM name_attributes
  JOIN taxon_names ON taxon_names.name_id = name_attributes.name_id
  GROUP BY taxon_id
) name_attributes ON taxa.id = name_attributes.taxon_id
LEFT JOIN (
  SELECT
    taxon_id,
    array_agg(DISTINCT vernacular_name) as names
  FROM vernacular_names
  JOIN taxon_names ON taxon_names.name_id = vernacular_names.name_id
  GROUP BY taxon_id
) vernacular_names ON taxa.id = vernacular_names.taxon_id;

CREATE UNIQUE INDEX species_id ON species (id);
CREATE INDEX species_dataset_id ON species (dataset_id);


-- Taxon classification
CREATE MATERIALIZED VIEW taxon_classification AS
SELECT
    taxon_id,
    array_agg(taxa_dag.canonical_name ORDER BY depth DESC) AS hierarchy,
    jsonb_object_agg(rank, canonical_name) AS ranks
FROM taxa_dag
GROUP BY taxon_id;

CREATE UNIQUE INDEX taxon_classification_taxon_id ON taxon_classification (taxon_id);


-- Statistics for all specimens
CREATE MATERIALIZED VIEW specimen_stats AS
SELECT DISTINCT
    specimens.entity_id,
    SUM(CASE WHEN sequences.record_id IS NOT NULL THEN 1 ELSE 0 END) OVER entities AS sequences,
    SUM(CASE WHEN annotation_events.representation IN ('Full', 'Partial') THEN 1 ELSE 0 END) OVER entities AS whole_genomes,
    SUM(CASE WHEN sequencing_events.target_gene IS NOT NULL THEN 1 ELSE 0 END) OVER entities AS loci,
    SUM(CASE WHEN sequencing_events.target_gene IS NULL AND assembly_events.id IS NULL THEN 1 ELSE 0 END) OVER entities AS other_genomic,
    SUM(CASE WHEN annotation_events.representation = 'Full' THEN 1 ELSE 0 END) OVER entities AS full_genomes,
    SUM(CASE WHEN annotation_events.representation = 'Partial' THEN 1 ELSE 0 END) OVER entities AS partial_genomes,
    SUM(CASE WHEN assembly_events.quality = 'Complete Genome' THEN 1 ELSE 0 END) OVER entities AS complete_genomes,
    SUM(CASE WHEN assembly_events.quality = 'Chromosome' THEN 1 ELSE 0 END) OVER entities AS assembly_chromosomes,
    SUM(CASE WHEN assembly_events.quality = 'Scaffold' THEN 1 ELSE 0 END) OVER entities AS assembly_scaffolds,
    SUM(CASE WHEN assembly_events.quality = 'Contig' THEN 1 ELSE 0 END) OVER entities AS assembly_contigs

FROM specimens
LEFT JOIN subsamples ON subsamples.specimen_id = specimens.entity_id
LEFT JOIN dna_extracts ON dna_extracts.subsample_id = subsamples.entity_id
LEFT JOIN sequences ON sequences.dna_extract_id = dna_extracts.entity_id
LEFT JOIN sequencing_events ON sequencing_events.sequence_id = sequences.id
LEFT JOIN annotation_events ON annotation_events.sequence_id = sequences.id
LEFT JOIN assembly_events ON assembly_events.sequence_id = sequences.id
WINDOW entities AS (partition BY specimens.entity_id ORDER BY specimens.entity_id DESC);

CREATE UNIQUE INDEX specimen_stats_entity_id ON specimen_stats(entity_id);


-- Very high level stats for all data in the ARGA database
CREATE MATERIALIZED VIEW overview AS
SELECT 'data_type' AS category, 'sequences' AS name, count(*) AS total FROM sequences
UNION ALL SELECT 'data_type' AS category, 'whole_genomes' AS name, count(*) AS total FROM whole_genomes
UNION ALL SELECT 'data_type' AS category, 'loci' AS name, count(*) AS total FROM markers
UNION ALL SELECT 'data_type' AS category, 'specimens' AS name, count(*) AS total FROM specimens

UNION ALL

SELECT 'source' AS category, sources.name, count(distinct name_id) as total FROM sources
LEFT JOIN datasets ON source_id=sources.id
LEFT JOIN name_attributes ON datasets.id = name_attributes.dataset_id
GROUP BY sources.name

UNION ALL

SELECT 'dataset' AS category, datasets.name, count(*) AS total FROM name_attributes
JOIN datasets ON name_attributes.dataset_id = datasets.id
WHERE name_attributes.name = 'last_updated'
GROUP BY datasets.name;



--------------------------------------
-- Operation log materialised views
--------------------------------------

CREATE MATERIALIZED VIEW collection_event_entities AS
SELECT entity_id FROM collection_event_logs GROUP BY entity_id ORDER BY entity_id;
CREATE UNIQUE INDEX collection_event_entities_entity_id ON collection_event_entities (entity_id);

CREATE MATERIALIZED VIEW organism_entities AS
SELECT entity_id FROM organism_logs GROUP BY entity_id ORDER BY entity_id;
CREATE UNIQUE INDEX organism_entities_entity_id ON organism_entities (entity_id);

CREATE MATERIALIZED VIEW tissue_entities AS
SELECT entity_id FROM tissue_logs GROUP BY entity_id ORDER BY entity_id;
CREATE UNIQUE INDEX tissue_entities_entity_id ON tissue_entities (entity_id);

CREATE MATERIALIZED VIEW accession_event_entities AS
SELECT entity_id FROM accession_event_logs GROUP BY entity_id ORDER BY entity_id;
CREATE UNIQUE INDEX accession_event_entities_entity_id ON accession_event_entities (entity_id);

CREATE MATERIALIZED VIEW subsample_entities AS
SELECT entity_id FROM subsample_logs GROUP BY entity_id ORDER BY entity_id;
CREATE UNIQUE INDEX subsample_entities_entity_id ON subsample_entities (entity_id);

CREATE MATERIALIZED VIEW extraction_entities AS
SELECT entity_id FROM extraction_logs GROUP BY entity_id ORDER BY entity_id;
CREATE UNIQUE INDEX extraction_entities_entity_id ON extraction_entities (entity_id);

CREATE MATERIALIZED VIEW agent_entities AS
SELECT entity_id FROM agent_logs GROUP BY entity_id ORDER BY entity_id;
CREATE UNIQUE INDEX agent_entities_entity_id ON agent_entities (entity_id);

CREATE MATERIALIZED VIEW publication_entities AS
SELECT entity_id FROM publication_logs GROUP BY entity_id ORDER BY entity_id;
CREATE UNIQUE INDEX publication_entities_entity_id ON publication_entities (entity_id);

CREATE MATERIALIZED VIEW library_entities AS
SELECT entity_id FROM library_logs GROUP BY entity_id ORDER BY entity_id;
CREATE UNIQUE INDEX library_entities_entity_id ON library_entities (entity_id);

CREATE MATERIALIZED VIEW sequence_run_entities AS
SELECT entity_id FROM sequence_run_logs GROUP BY entity_id ORDER BY entity_id;
CREATE UNIQUE INDEX sequence_run_entities_entity_id ON sequence_run_entities (entity_id);

CREATE MATERIALIZED VIEW assembly_entities AS
SELECT entity_id FROM assembly_logs GROUP BY entity_id ORDER BY entity_id;
CREATE UNIQUE INDEX assembly_entities_entity_id ON assembly_entities (entity_id);

CREATE MATERIALIZED VIEW data_product_entities AS
SELECT entity_id FROM data_product_logs GROUP BY entity_id ORDER BY entity_id;
CREATE UNIQUE INDEX data_product_entities_entity_id ON data_product_entities (entity_id);
